import SkeletonBox from '@/components/Skeleton';
import { useDesign } from '@/context/DesignSystem';
import { db } from '@/firebase/config';
import { getCurrentUser } from '@/services/authService';
import { setScrollCallback } from '@/utils/scrollRefManager';
import { Ionicons } from '@expo/vector-icons';
import { createMaterialTopTabNavigator } from '@react-navigation/material-top-tabs';
import dayjs from 'dayjs';
import { Image } from 'expo-image';
import { useFocusEffect, useLocalSearchParams, useRouter } from 'expo-router';
import {
  collection,
  getDocs,
  limit,
  onSnapshot,
  orderBy,
  query,
  startAfter,
  where,
} from 'firebase/firestore';
import React, { useCallback, useEffect, useRef, useState } from 'react';
import {
  Dimensions,
  FlatList,
  // Image,
  Modal,
  Platform,
  RefreshControl,
  StyleSheet,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from 'react-native';
import { EdgeInsets, useSafeAreaFrame, useSafeAreaInsets } from 'react-native-safe-area-context';
import styled from 'styled-components/native';
// const SCREEN_WIDTH = Dimensions.get('window').width;

// Define the theme interface
interface Theme {
  colors: {
    background: string;
    primary: string;
    surface: string;
    text: string;
    border: string;
    subtext: string;
  };
  radius: {
    lg: number;
  };
  spacing: {
    md: number;
    sm: number;
  };
  font: {
    body: number;
    heading: number;
  };
}

// Styled components
const SafeArea = styled.SafeAreaView<{ insets: EdgeInsets }>`
  flex: 1;
  background-color: ${({ theme }: { theme: Theme }) => theme.colors.background};
`;

const Header = styled.View<{ theme: Theme }>`
  width: 100%;
  flex-direction: row;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  padding-top: ${Platform.OS === 'ios' ? 15 : 10}px;
  padding-horizontal: 15px;
`;

const Title = styled.Text<{ theme: Theme }>`
  font-size: 24px;
  font-weight: bold;
  color: ${({ theme }: any) => theme.colors.text};
`;

const Actions = styled.View<{ theme: Theme }>`
  flex-direction: row;
  gap: 16px;
`;

const SearchInputContainer = styled.View<{ theme: Theme }>`
  padding-horizontal: 15px;
  margin-bottom: 10px;
`;

const SearchInput = styled.TextInput<{ theme: Theme }>`
  border-width: 1px;
  border-color: ${({ theme }: any) => theme.colors.border};
  border-radius: 8px;
  padding-horizontal: 12px;
  padding-vertical: 8px;
  color: ${({ theme }: any) => theme.colors.text};
  background-color: ${({ theme }: any) => theme.colors.surface};
`;

const FilterSortContainer = styled.View<{ theme: Theme }>`
  flex-direction: row;
  justify-content: space-between;
  align-items: center;
  border-top-width: 1px;
  border-bottom-width: 1px;
  border-color: ${({ theme }: any) => theme.colors.border};
  margin-horizontal: ${({ theme }: any) => theme.spacing.md}px;
  padding-vertical: ${({ theme }: any) => theme.spacing.sm}px;
`;

const FilterButton = styled(TouchableOpacity)<{ theme: Theme }>`
  flex-direction: row;
  align-items: center;
  justify-content: space-around;
  min-width: 100px;
`;

const CategoryButton = styled(TouchableOpacity)<{ theme: Theme }>`
  flex-direction: row;
  align-items: center;
  justify-content: space-around;
  flex: 1;
  min-width: 150px;
`;

const SortButton = styled(TouchableOpacity)<{ theme: Theme }>`
  flex-direction: row;
  align-items: center;
  justify-content: space-around;
  min-width: 150px;
`;

const StyledText = styled.Text<{ theme: Theme }>`
  color: ${({ theme }: any) => theme.colors.text};
  font-size: ${({ theme }: any) => theme.font.body}px;
`;

const StyledIcon = styled(Ionicons)<{ theme: Theme }>`
  color: ${({ theme }: any) => theme.colors.text};
`;

const NoTeamsView = styled.View<{ theme: Theme }>`
  align-items: center;
  margin-top: 40px;
`;

const NoTeamsText = styled.Text<{ theme: Theme }>`
  color: ${({ theme }: any) => theme.colors.subtext};
`;

const Tab = createMaterialTopTabNavigator();

export default function TeamsList() {
  const [teams, setTeams] = useState<any[]>([]);
  const [loading, setLoading] = useState(true);
  const [isGrid, setIsGrid] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [lastDoc, setLastDoc] = useState<any>(null);
  const [hasMore, setHasMore] = useState(true);
  const mainListRef = useRef<FlatList>(null);
  const router = useRouter();
  const { colors, radius, spacing, font } = useDesign();
  const frame = useSafeAreaFrame();
  const SCREEN_WIDTH = frame.width;
  const insets = useSafeAreaInsets();
  const [searchQuery, setSearchQuery] = useState('');
  const [isSearchVisible, setIsSearchVisible] = useState(false);
  const searchInputRef = useRef<TextInput>(null);
  const [sortOption, setSortOption] = useState('ÏµúÏã†Í∞úÏÑ§Ïàú');
  const [isCategoryModalVisible, setCategoryModalVisible] = useState(false);
  const [isSortModalVisible, setSortModalVisible] = useState(false);
  const [userEmail, setUserEmail] = useState('');
  const [allTeams, setAllTeams] = useState<any[]>([]);
  const [currentUserUid, setCurrentUserUid] = useState('');
  const [isFilterModalVisible, setFilterModalVisible] = useState(false);
  const [activeTab, setActiveTab] = useState<'teams' | 'community'>('teams');
  // ÌÜµÌï© ÌïÑÌÑ∞ ÏÉÅÌÉú Í¥ÄÎ¶¨
  const [filters, setFilters] = useState({
    category: '',
    memberStatus: {
      recruitingOnly: false,
      joinedOnly: false,
    },
  });
  const { filter } = useLocalSearchParams(); // filter param Î∞õÏïÑÏò§Í∏∞
  const [firstLoad, setFirstLoad] = useState(true);
  const categories = [
    '‚ú® Î∞òÏßùÏÜåÎ™®ÏûÑ',
    'üèÉ Ïö¥Îèô/Ïä§Ìè¨Ï∏†',
    'üìö Ï±ÖÎ™®ÏûÑ',
    'üéÆ Í≤åÏûÑ',
    'üé≠ Î¨∏ÌôîÏÉùÌôú',
    'ü§ù Î¥âÏÇ¨',
    'üìñ Ïä§ÌÑ∞Îîî',
    'üêæ ÎèôÎ¨º',
    'üç≥ ÏöîÎ¶¨/Ï†úÏ°∞',
  ];

  useEffect(() => {
    const fetchUser = async () => {
      const user = await getCurrentUser();
      if (user?.email) {
        setUserEmail(user.email);
      }
      if (user?.uid) {
        setCurrentUserUid(user.uid);
      }
    };
    fetchUser();
  }, []);

  useEffect(() => {
    setScrollCallback('teams', () => {
      mainListRef.current?.scrollToOffset({ offset: 0, animated: true });
    });
  }, []);

  useEffect(() => {
    if (typeof filter === 'string' && filter.length > 0) {
      setFilters((prev) => ({ ...prev, category: filter }));
    } else {
      // üîÅ filter ÏóÜÏúºÎ©¥ Ï†ÑÏ≤¥ Î™©Î°ù
      setFilters((prev) => ({ ...prev, category: '' }));
    }
  }, [filter]);

  // ÌïÑÌÑ∞ÎßÅ Ï†ÅÏö© Î°úÏßÅ
  useEffect(() => {
    if (!allTeams.length) return;

    applyFilters();
  }, [filters, allTeams, searchQuery]);

  const fetchTeams = useCallback(
    async (isInitial = false) => {
      if (!hasMore && !isInitial) return;

      try {
        if (isInitial) {
          setLoading(true);
          setLastDoc(null);
          setHasMore(true);
        }

        const baseQuery = query(
          collection(db, 'teams'),
          where('approved', '==', true),
          orderBy('createdAt', 'desc'),
          ...(isInitial || !lastDoc ? [] : [startAfter(lastDoc)]),
          limit(10)
        );

        const snap = await getDocs(baseQuery);
        const fetched = snap.docs.map((doc) => ({ id: doc.id, ...doc.data() }));

        if (isInitial) {
          setTeams(fetched);
          setAllTeams(fetched);
        } else {
          setTeams((prev) => [...prev, ...fetched]);
          setAllTeams((prev) => [...prev, ...fetched]);
        }

        setLastDoc(snap.docs[snap.docs.length - 1] ?? null);
        setHasMore(snap.size === 10);
      } catch (e) {
        console.error('üî• fetchTeams error:', e);
      } finally {
        if (isInitial) setLoading(false);
      }
    },
    [lastDoc, hasMore]
  );

  useEffect(() => {
    fetchTeams(true);
  }, []);

  useFocusEffect(
    useCallback(() => {
      // ÌôîÎ©¥Ïóê Ìè¨Ïª§Ïä§Îê† ÎïåÎßàÎã§ ÌïÑÌÑ∞ÎßÅ Ï¥àÍ∏∞Ìôî Î∞è Îç∞Ïù¥ÌÑ∞ ÏÉàÎ°úÍ≥†Ïπ®
      if (!filter || filter === '') {
        setFilters((prev) => ({ ...prev, category: '' }));
        fetchTeams(true);
      }
    }, [filter])
  );

  useEffect(() => {
    const q = query(
      collection(db, 'teams'),
      where('approved', '==', true),
      orderBy('createdAt', 'desc'),
      limit(2)
    );

    const unsubscribe = onSnapshot(q, (snapshot) => {
      const newDocs = snapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() }));

      setTeams((prev) => {
        const updated = [...prev];
        const ids = new Set(prev.map((item) => item.id));

        newDocs.forEach((doc) => {
          const index = updated.findIndex((item) => item.id === doc.id);
          if (index >= 0) {
            updated[index] = doc;
          } else {
            updated.unshift(doc);
          }
        });

        return updated;
      });
    });

    return () => unsubscribe();
  }, []);

  const onRefresh = async () => {
    setRefreshing(true);
    await fetchTeams(true);
    setRefreshing(false);
  };

  const handlePress = (id: string) => {
    router.push(`/teams/${id}`);
  };

  // ÌïÑÌÑ∞ Ï†ÅÏö© Ìï®Ïàò
  const applyFilters = () => {
    let filtered = [...allTeams];

    // Ïπ¥ÌÖåÍ≥†Î¶¨ ÌïÑÌÑ∞ Ï†ÅÏö©
    if (filters.category) {
      filtered = filtered.filter((team) => team.category === filters.category);
    }

    // Î™®Ïßë ÏÉÅÌÉú ÌïÑÌÑ∞ Ï†ÅÏö©
    if (filters.memberStatus.recruitingOnly) {
      filtered = filtered.filter((team) => {
        const members = team.membersList?.length ?? 0;
        const max = team.maxMembers ?? null;
        const isUnlimited = max === -1 || max === null || max === undefined;
        const isFull = !isUnlimited && typeof max === 'number' && members >= max;
        return !isFull && !team.isClosed;
      });
    }

    // Í∞ÄÏûÖÎêú Î™®ÏûÑ ÌïÑÌÑ∞ Ï†ÅÏö©
    if (filters.memberStatus.joinedOnly) {
      filtered = filtered.filter(
        (team) => Array.isArray(team.membersList) && team.membersList.includes(userEmail)
      );
    }

    // Í≤ÄÏÉâÏñ¥ Ï†ÅÏö©
    if (searchQuery) {
      const keyword = searchQuery.toLowerCase();
      filtered = filtered.filter(
        (team) =>
          team.name?.toLowerCase().includes(keyword) || team.leader?.toLowerCase().includes(keyword)
      );
    }

    // Ï†ïÎ†¨ Ï†ÅÏö©
    if (sortOption === 'ÏµúÏã†Í∞úÏÑ§Ïàú') {
      filtered.sort((a, b) => b.createdAt - a.createdAt);
    } else if (sortOption === 'Î©§Î≤ÑÏàò ÎßéÏùÄ Ïàú') {
      filtered.sort((a, b) => (b.membersList?.length || 0) - (a.membersList?.length || 0));
    } else if (sortOption === 'Î©§Î≤ÑÏàò Ï†ÅÏùÄ Ïàú') {
      filtered.sort((a, b) => (a.membersList?.length || 0) - (b.membersList?.length || 0));
    }

    setTeams(filtered);
  };

  const handleFilterChange = (option: string) => {
    if (option === 'ÏÉÅÏÑ∏ ÌïÑÌÑ∞') {
      setFilterModalVisible(true);
      return;
    }

    // Í∞ÑÏÜåÌôîÎêú ÌïÑÌÑ∞ Ï†ÅÏö© - ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏Îßå ÏàòÌñâ
    if (option === 'Î©§Î≤Ñ Î™®ÏßëÏ§ëÏù∏ Î™®ÏûÑÎßå Î≥¥Í∏∞') {
      setFilters((prev) => ({
        ...prev,
        memberStatus: {
          ...prev.memberStatus,
          recruitingOnly: !prev.memberStatus.recruitingOnly,
        },
      }));
    } else if (option === 'ÎÇ¥Í∞Ä Í∞ÄÏûÖÎêú Î™®ÏûÑÎßå Î≥¥Í∏∞') {
      setFilters((prev) => ({
        ...prev,
        memberStatus: {
          ...prev.memberStatus,
          joinedOnly: !prev.memberStatus.joinedOnly,
        },
      }));
    }
  };

  const GRID_SPACING = 12;
  const GRID_COLUMNS = 2;

  // Ïú†ÎèôÏ†Å Ïç∏ÎÑ§Ïùº ÌÅ¨Í∏∞ Í≥ÑÏÇ∞
  const thumbnailWidth = isGrid
    ? (SCREEN_WIDTH - (GRID_COLUMNS + 1) * GRID_SPACING) / GRID_COLUMNS
    : 100; // Î¶¨Ïä§Ìä∏ Î™®Îìú Í≥†Ï†ï ÎÜíÏù¥
  const cardWidth = isGrid
    ? (SCREEN_WIDTH - 3 * 12) / 2 // Í∑∏Î¶¨Îìú Î™®Îìú Ïπ¥Îìú ÎÑàÎπÑ
    : SCREEN_WIDTH - 32; // Î¶¨Ïä§Ìä∏ Î™®Îìú Ïπ¥Îìú ÎÑàÎπÑ
  const thumbnailHeight = isGrid ? thumbnailWidth * 0.7 : 100; // 16:9 ÎπÑÏú®

  const renderFilterModal = () => (
    <Modal
      visible={isFilterModalVisible}
      transparent
      animationType='slide'
      onRequestClose={() => setFilterModalVisible(false)}>
      <TouchableOpacity
        activeOpacity={1}
        onPressOut={() => setFilterModalVisible(false)}
        style={{ flex: 1, justifyContent: 'flex-end', backgroundColor: 'rgba(0,0,0,0.5)' }}>
        <TouchableOpacity
          activeOpacity={1}
          style={{
            position: 'absolute',
            bottom: 0,
            width: '100%',
            backgroundColor: colors.background,
            paddingHorizontal: spacing.md,
            paddingTop: 16,
            paddingBottom: (insets.bottom || 20) + 30,
          }}>
          {/* Ìï∏Îì§ */}
          <View style={{ alignItems: 'center', marginBottom: 20 }}>
            <View style={{ width: 40, height: 4, borderRadius: 2, backgroundColor: '#ccc' }} />
          </View>

          {/* ÌïÑÌÑ∞ Ìï≠Î™© */}
          <TouchableOpacity
            onPress={() => handleFilterChange('Î©§Î≤Ñ Î™®ÏßëÏ§ëÏù∏ Î™®ÏûÑÎßå Î≥¥Í∏∞')}
            style={{
              flexDirection: 'row',
              alignItems: 'center',
              justifyContent: 'space-between',
              paddingVertical: spacing.md,
            }}>
            <Text style={{ fontSize: font.body, color: colors.text, marginRight: 10 }}>
              Î™®ÏßëÏÉÅÌÉú: Î©§Î≤Ñ Î™®ÏßëÏ§ëÏù∏ Î™®ÏûÑÎßå Î≥¥Í∏∞
            </Text>
            <Ionicons
              name={filters.memberStatus.recruitingOnly ? 'checkbox' : 'square-outline'}
              size={20}
              color={colors.primary}
            />
          </TouchableOpacity>

          <TouchableOpacity
            onPress={() => handleFilterChange('ÎÇ¥Í∞Ä Í∞ÄÏûÖÎêú Î™®ÏûÑÎßå Î≥¥Í∏∞')}
            style={{
              flexDirection: 'row',
              alignItems: 'center',
              justifyContent: 'space-between',
              paddingVertical: spacing.md,
            }}>
            <Text style={{ fontSize: font.body, color: colors.text, marginRight: 10 }}>
              ÎÇ¥ Î™®ÏûÑ: ÎÇ¥Í∞Ä Í∞ÄÏûÖÎêú Î™®ÏûÑÎßå Î≥¥Í∏∞
            </Text>
            <Ionicons
              name={filters.memberStatus.joinedOnly ? 'checkbox' : 'square-outline'}
              size={20}
              color={colors.primary}
            />
          </TouchableOpacity>
        </TouchableOpacity>
      </TouchableOpacity>
    </Modal>
  );

  const renderCategoryModal = () => (
    <Modal
      visible={isCategoryModalVisible}
      transparent
      animationType='slide'
      onRequestClose={() => setCategoryModalVisible(false)}>
      <TouchableOpacity
        style={{ flex: 1, backgroundColor: 'rgba(0,0,0,0.5)' }}
        activeOpacity={1}
        onPressOut={() => setCategoryModalVisible(false)}>
        <View
          style={{
            position: 'absolute',
            bottom: 0,
            width: '100%',
            backgroundColor: colors.background,
            paddingTop: 16,
            paddingBottom: insets.bottom + 20,
            borderTopLeftRadius: 16,
            borderTopRightRadius: 16,
          }}>
          {/* Ìï∏Îì§ */}
          <View style={{ alignItems: 'center', marginBottom: 20 }}>
            <View
              style={{
                width: 40,
                height: 4,
                borderRadius: 2,
                backgroundColor: '#ccc',
              }}
            />
          </View>

          {/* Ï†ÑÏ≤¥ Ïπ¥ÌÖåÍ≥†Î¶¨ */}
          <TouchableOpacity
            onPress={() => {
              handleCategorySelect('Ï†ÑÏ≤¥');
              setCategoryModalVisible(false);
            }}
            style={{
              paddingVertical: spacing.sm,
              alignItems: 'center',
            }}>
            <Text
              style={{
                fontSize: font.body,
                color: filters.category === '' ? colors.primary : colors.text,
                fontWeight: filters.category === '' ? 'bold' : 'normal',
              }}>
              Ï†ÑÏ≤¥
            </Text>
          </TouchableOpacity>

          {/* ÎÇòÎ®∏ÏßÄ Ïπ¥ÌÖåÍ≥†Î¶¨ */}
          {categories.map((category) => (
            <TouchableOpacity
              key={category}
              onPress={() => {
                handleCategorySelect(category);
                setCategoryModalVisible(false);
              }}
              style={{
                paddingVertical: spacing.sm,
                alignItems: 'center',
              }}>
              <Text
                style={{
                  fontSize: font.body,
                  color: filters.category === category ? colors.primary : colors.text,
                  fontWeight: filters.category === category ? 'bold' : 'normal',
                }}>
                {category}
              </Text>
            </TouchableOpacity>
          ))}
        </View>
      </TouchableOpacity>
    </Modal>
  );

  const handleSortChange = (option: string) => {
    // Ï†ïÎ†¨ ÏòµÏÖò ÏÑ§Ï†ïÎßå ÏàòÌñâ - applyFiltersÏóêÏÑú Ïã§Ï†ú Ï†ïÎ†¨ Î°úÏßÅ Ïã§Ìñâ
    setSortOption(option);
    setSortModalVisible(false);

    // Ï†ïÎ†¨ Ï¶âÏãú Ï†ÅÏö©
    setTimeout(applyFilters, 0);
  };

  const handleCategorySelect = (category: string) => {
    // ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏Îßå ÏàòÌñâ
    setFilters((prev) => ({
      ...prev,
      category: category === 'Ï†ÑÏ≤¥' ? '' : category,
    }));
    setCategoryModalVisible(false);
  };

  const renderSortModal = () => (
    <Modal visible={isSortModalVisible} transparent animationType='slide'>
      <TouchableOpacity
        activeOpacity={1}
        onPressOut={() => setSortModalVisible(false)}
        style={{ flex: 1, justifyContent: 'flex-end', backgroundColor: 'rgba(0,0,0,0.5)' }}>
        <TouchableOpacity
          activeOpacity={1}
          style={{
            position: 'absolute',
            bottom: 0,
            width: '100%',
            backgroundColor: colors.background,
            paddingHorizontal: spacing.md,
            paddingTop: 16,
            paddingBottom: insets.bottom + 30,
            borderTopLeftRadius: 16,
            borderTopRightRadius: 16,
          }}>
          {/* Ìï∏Îì§Î∞î */}
          <View style={{ alignItems: 'center', marginBottom: 20 }}>
            <View style={{ width: 40, height: 4, borderRadius: 2, backgroundColor: '#ccc' }} />
          </View>

          {['ÏµúÏã†Í∞úÏÑ§Ïàú', 'Î©§Î≤ÑÏàò ÎßéÏùÄ Ïàú', 'Î©§Î≤ÑÏàò Ï†ÅÏùÄ Ïàú'].map((option) => (
            <TouchableOpacity
              key={option}
              onPress={() => {
                handleSortChange(option);
                setSortModalVisible(false);
              }}
              style={{
                paddingVertical: spacing.md,
                alignItems: 'center',
              }}>
              <Text
                style={{
                  color: sortOption === option ? colors.primary : colors.subtext,
                  fontSize: font.heading,
                  fontWeight: sortOption === option ? 'bold' : 'normal',
                }}>
                {option}
              </Text>
            </TouchableOpacity>
          ))}
        </TouchableOpacity>
      </TouchableOpacity>
    </Modal>
  );

  const renderItem = ({ item }: { item: any }) => {
    const members = item.membersList?.length ?? 0;
    const max = item.maxMembers ?? null;
    const isUnlimited = max === -1 || max === null || max === undefined;
    const isFull = !isUnlimited && typeof max === 'number' && members >= max;
    return (
      <TouchableOpacity
        key={item.id}
        style={{
          flexDirection: isGrid ? 'column' : 'row',
          alignItems: 'center',
          backgroundColor: colors.surface,
          borderColor: colors.border,
          borderWidth: 1,
          borderRadius: 16,
          padding: 12,
          margin: 6,
          width: isGrid ? (SCREEN_WIDTH - 3 * 12) / 2 : SCREEN_WIDTH - 32, // Î¶¨Ïä§Ìä∏ Î™®ÎìúÏùº Îïå Îçî ÎÑìÍ≤å
          shadowColor: '#000',
          shadowOffset: { width: 0, height: 1 },
          shadowOpacity: 0.05,
          shadowRadius: 4,
          elevation: 2,
          overflow: 'hidden',
        }}
        onPress={() => handlePress(item.id)}>
        {item.thumbnail ? (
          <Image
            source={{ uri: item.thumbnail }}
            style={{
              width: isGrid ? '100%' : 100,
              height: isGrid ? thumbnailHeight : 100,
              borderRadius: 8,
              backgroundColor: '#eee',
              marginRight: isGrid ? 0 : 12,
              marginBottom: isGrid ? 8 : 0,
            }}
            cachePolicy='disk'
            contentFit='cover'
          />
        ) : (
          <View
            style={{
              width: isGrid ? '100%' : 100,
              height: isGrid ? thumbnailHeight : 100,
              borderRadius: 8,
              backgroundColor: '#eee',
              marginRight: 12,
              marginBottom: isGrid ? 8 : 0,
            }}
          />
        )}

        <View style={{ flex: 1 }}>
          <View
            style={{
              flexDirection: 'row',
              alignItems: 'center',
              justifyContent: 'space-between',
              marginBottom: 4,
            }}>
            <Text style={{ fontSize: isGrid ? 16 : 18, fontWeight: '600', color: colors.text }}>
              {item.name}
            </Text>

            {item.category === '‚ú® Î∞òÏßùÏÜåÎ™®ÏûÑ' && (
              <Text style={{ fontSize: 12, color: colors.notification, fontWeight: 'bold' }}>
                D-{dayjs(item.expirationDate.seconds * 1000).diff(dayjs(), 'day')}
              </Text>
            )}
          </View>
          <Text style={{ fontSize: 13, color: colors.primary, marginBottom: 8 }}>
            {item.category ? `(${item.category})` : '(Ïπ¥ÌÖåÍ≥†Î¶¨ ÏóÜÏùå)'}
          </Text>

          <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 4 }}>
            <Ionicons
              name='person-outline'
              size={14}
              color={colors.subtext}
              style={{ marginRight: 4 }}
            />
            <Text style={{ fontSize: 12, color: colors.subtext }}>Î™®ÏûÑÏû•: {item.leader}</Text>
          </View>

          <View style={{ flexDirection: 'row', alignItems: 'center' }}>
            <Ionicons
              name='people-outline'
              size={14}
              color={isFull ? colors.error : colors.subtext}
              style={{ marginRight: 4 }}
            />
            <Text
              style={{
                fontSize: 12,
                color: isFull || item.isClosed ? colors.error : colors.subtext,
              }}>
              Ïù∏Ïõê: {members} / {isUnlimited ? 'Î¨¥Ï†úÌïú' : max}
              {isFull || item.isClosed ? ' (Î™®ÏßëÎßàÍ∞ê)' : '(Î™®ÏßëÏ§ë)'}
            </Text>
          </View>
        </View>
      </TouchableOpacity>
    );
  };

  const renderSkeletons = () => (
    <View style={{ flexDirection: isGrid ? 'row' : 'column', flexWrap: 'wrap', gap: 16 }}>
      {Array.from({ length: 4 }).map((_, i) => (
        <View key={i} style={isGrid ? styles.gridItem : styles.listItem}>
          <SkeletonBox width={180} height={18} />
          <SkeletonBox width={120} height={16} />
          <SkeletonBox width={100} height={16} />
        </View>
      ))}
    </View>
  );

  return (
    <SafeArea insets={insets}>
      <Header>
        <Title>üìã ÏÜåÎ™®ÏûÑ Î™©Î°ù</Title>
        <Actions>
          <TouchableOpacity
            onPress={() => {
              setIsSearchVisible((prev) => !prev);
              setTimeout(() => searchInputRef.current?.focus(), 100);
            }}>
            <StyledIcon name={isSearchVisible ? 'close' : 'search'} size={24} />
          </TouchableOpacity>
          <TouchableOpacity onPress={() => router.push('/teams/create')}>
            <StyledIcon name='add-circle-outline' size={26} />
          </TouchableOpacity>
          <TouchableOpacity onPress={() => setIsGrid(!isGrid)}>
            <StyledIcon name={isGrid ? 'list-outline' : 'grid-outline'} size={24} />
          </TouchableOpacity>
        </Actions>
      </Header>

      {isSearchVisible && (
        <SearchInputContainer>
          <SearchInput
            ref={searchInputRef}
            placeholder='ÌåÄ Ïù¥Î¶Ñ ÎòêÎäî Î™®ÏûÑÏû•ÏúºÎ°ú Í≤ÄÏÉâ'
            placeholderTextColor={colors.subtext}
            value={searchQuery}
            onChangeText={(text: any) => {
              setSearchQuery(text);
              // ÎîîÎ∞îÏö¥Ïä§ Ìö®Í≥ºÎ•º ÏúÑÌï¥ ÌÉÄÏù¥Î®∏ ÏÑ§Ï†ï
              if (text.length === 0 || text.length > 2) {
                setTimeout(applyFilters, 300);
              }
            }}
          />
        </SearchInputContainer>
      )}

      <FilterSortContainer>
        <FilterButton onPress={() => handleFilterChange('ÏÉÅÏÑ∏ ÌïÑÌÑ∞')}>
          <StyledText>ÏÉÅÏÑ∏ ÌïÑÌÑ∞</StyledText>
          <StyledIcon name='filter' size={18} />
        </FilterButton>

        <View style={{ height: '100%', width: 1, backgroundColor: colors.border }} />

        <CategoryButton onPress={() => setCategoryModalVisible(true)}>
          <StyledText>{filters.category ? filters.category : 'Ïπ¥ÌÖåÍ≥†Î¶¨'}</StyledText>
          <StyledIcon name='chevron-down' size={18} style={{ marginLeft: 4 }} />
        </CategoryButton>

        <View style={{ height: '100%', width: 1, backgroundColor: colors.border }} />

        <SortButton onPress={() => setSortModalVisible(true)}>
          <StyledText>{sortOption}</StyledText>
          <StyledIcon name='swap-vertical' size={18} style={{ marginRight: 20 }} />
        </SortButton>
      </FilterSortContainer>

      {renderFilterModal()}
      {renderCategoryModal()}
      {renderSortModal()}

      {loading && !refreshing ? (
        renderSkeletons()
      ) : teams.length === 0 ? (
        <NoTeamsView>
          <NoTeamsText>Îì±Î°ùÎêú ÏÜåÎ™®ÏûÑÏù¥ ÏóÜÏäµÎãàÎã§.</NoTeamsText>
        </NoTeamsView>
      ) : (
        <FlatList
          ref={mainListRef}
          data={teams}
          key={isGrid ? 'grid' : 'list'}
          numColumns={isGrid ? 2 : 1}
          keyExtractor={(item) => item.id}
          renderItem={renderItem}
          contentContainerStyle={[styles.listContent, !isGrid && { paddingHorizontal: 10 }]}
          columnWrapperStyle={isGrid && { gap: 4 }}
          refreshControl={<RefreshControl refreshing={refreshing} onRefresh={onRefresh} />}
          onEndReachedThreshold={0.3}
          onEndReached={() => fetchTeams()}
        />
      )}
    </SafeArea>
  );
}

const screenWidth = Dimensions.get('window').width;

const styles = StyleSheet.create({
  listContent: {
    alignItems: 'center',
    paddingBottom: 60,
    width: '100%',
  },
  gridItem: {
    width: (screenWidth - 60) / 2,
    borderRadius: 16,
    padding: 16,
    margin: 8,
    alignItems: 'flex-start',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.06,
    shadowRadius: 4,
    elevation: 3,
  },
  listItem: {
    width: screenWidth - 40,
    flexDirection: 'row',
    borderRadius: 16,
    padding: 16,
    marginVertical: 8,
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.06,
    shadowRadius: 4,
    elevation: 3,
    borderWidth: 1,
  },
  textContainer: {
    flexShrink: 1,
  },
  name: {
    fontSize: 16,
    fontWeight: '600',
    marginBottom: 4,
  },
  meta: {
    fontSize: 14,
  },
  fullText: {
    fontWeight: 'bold',
  },
  filterSortContainer: {
    flexDirection: 'row',
    gap: 1,
    padding: 10,
  },
  filterButton: {},
});
